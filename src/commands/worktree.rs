//! Worktree operations emit either user-facing messages or directives for shell wrappers.
//!
//! # Why dual mode?
//! Worktree commands must change the parent shell's directory, which a child process cannot do.
//! Without integration, we print paths and the user `cd`s manually. With integration, we emit
//! directives that the shell wrapper executes on the user's behalf.
//!
//! ## Without `--internal`
//! - Git operations run normally and messages print to stderr
//! - Shell stays in place; user manually switches directories
//!
//! ## With `--internal` (shell wrapper)
//! - Wrapper calls `wt switch --internal ...`
//! - Stdout carries NUL-delimited directives such as `__WORKTRUNK_CD__/path\0`
//! - Stderr streams status in real time
//! - Wrapper parses directives and performs the `cd`/exec in the parent shell
//!
//! Directives support multi-line commands for `-x` and are generated by templates from
//! `wt init <shell>`.
//!
//! ## Exit codes with `-x`
//! - wt failure returns wt's exit code; the command is not run
//! - wt success with a failing command returns the command's exit code
//!
//! Result types (`SwitchResult`, `RemoveResult`) stay data-only. Presentation lives in
//! `output::handle_switch_output()` and `output::handle_remove_output()`, which pick the right
//! mode based on the `internal` flag.

use std::path::PathBuf;
use worktrunk::HookType;
use worktrunk::config::{CommandPhase, WorktrunkConfig};
use worktrunk::git::{GitError, GitResultExt, Repository};
use worktrunk::styling::{CYAN, CYAN_BOLD, GREEN, GREEN_BOLD, WARNING, format_with_gutter};

use super::command_executor::CommandContext;
use super::hooks::{HookFailureStrategy, HookPipeline};
use super::repository_ext::RepositoryCliExt;

/// Flags indicating which merge operations occurred
#[derive(Debug, Clone, Copy)]
pub struct MergeOperations {
    pub committed: bool,
    pub squashed: bool,
    pub rebased: bool,
}

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Already at the target worktree (no action taken)
    AlreadyAt(PathBuf),
    /// Switched to existing worktree at the given path
    Existing(PathBuf),
    /// Created new worktree at the given path
    Created {
        path: PathBuf,
        created_branch: bool,
        base_branch: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::AlreadyAt(path) => path,
            SwitchResult::Existing(path) => path,
            SwitchResult::Created { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Removed worktree and returned to primary (if needed)
    RemovedWorktree {
        primary_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        branch_name: String,
        no_delete_branch: bool,
        force_delete: bool,
        target_branch: Option<String>,
    },
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    no_verify: bool,
    config: &WorktrunkConfig,
) -> Result<(SwitchResult, String), GitError> {
    let repo = Repository::current();

    // Get current history (current, previous) before resolving
    let history_before = repo.get_switch_history();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo.resolve_worktree_name(branch)?;

    // Calculate what to record in history after the switch
    // History stores (current_location, previous_location) for ping-pong behavior
    let (new_current, new_previous) = if branch == "-" {
        // Switching back: swap current and previous
        // history_before contains (A, B), we're switching from A to B
        // After switch, record (B, A) so we can switch back to A
        if let Some(history) = history_before {
            (resolved_branch.clone(), Some(history.current))
        } else {
            // No history - shouldn't happen since "-" requires history
            // But handle gracefully: just record where we're going
            (resolved_branch.clone(), None)
        }
    } else {
        // Normal switch: record new location as current, old current as previous
        let previous = history_before.map(|h| h.current);
        (resolved_branch.clone(), previous)
    };

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: resolved_branch.clone(),
        });
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::warning(format!(
            "{WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        ))?;
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            // Record successful switch in history for `wt switch -` support
            let _ = repo.record_switch_history(&new_current, new_previous.as_deref());

            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);

            // Check if we're already at this worktree
            let current_dir = std::env::current_dir()
                .ok()
                .and_then(|p| p.canonicalize().ok());

            let already_at_worktree = current_dir
                .as_ref()
                .map(|cur| cur == &canonical_existing_path)
                .unwrap_or(false);

            return Ok((
                if already_at_worktree {
                    SwitchResult::AlreadyAt(canonical_existing_path)
                } else {
                    SwitchResult::Existing(canonical_existing_path)
                },
                resolved_branch,
            ));
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: resolved_branch.clone(),
            });
        }
        None => {}
    }

    // No existing worktree, create one
    let repo_root = repo.worktree_base()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| GitError::message("Invalid repository path"))?
        .to_str()
        .ok_or_else(|| GitError::message("Invalid UTF-8 in path"))?;

    let worktree_path = repo_root.join(
        config
            .format_path(repo_name, &resolved_branch)
            .map_err(|e| GitError::message(format!("Failed to format worktree path: {}", e)))?,
    );

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];

    // Use the resolved base, or default to default branch if creating without a base
    let base_for_creation = if create {
        match resolved_base {
            Some(b) => Some(b),
            None => Some(repo.resolve_target_branch(None)?),
        }
    } else {
        None
    };

    // Build args based on whether we're creating or checking out
    if create {
        args.push("-b");
        args.push(&resolved_branch);
        if let Some(ref base_branch) = base_for_creation {
            args.push(base_branch);
        }
    } else {
        args.push(&resolved_branch);
    }

    // Create worktree and parse specific error cases
    if let Err(e) = repo.run_command(&args) {
        // Check if error is about directory already existing
        if let GitError::CommandFailed(ref msg) = e
            && msg.contains("already exists")
        {
            // Parse the path from git's error message
            // Format: "fatal: '/path/to/dir' already exists"
            if let Some(path_str) = msg
                .lines()
                .find(|line| line.contains("already exists"))
                .and_then(|line| {
                    // Extract path between quotes
                    line.split('\'').nth(1).or_else(|| line.split('"').nth(1))
                })
            {
                let path = std::path::PathBuf::from(path_str);
                // Canonicalize if possible, otherwise use as-is
                let normalized_path = path.canonicalize().unwrap_or(path);
                return Err(GitError::WorktreePathExists {
                    path: normalized_path,
                });
            }
        }
        // Fall back to generic error with context
        return Err(match e {
            GitError::CommandFailed(msg) => GitError::WorktreeCreationFailed {
                branch: resolved_branch.clone(),
                base_branch: base_for_creation.clone(),
                error: msg,
            },
            other => other,
        });
    }

    // Canonicalize the path to resolve any .. components
    let worktree_path = worktree_path
        .canonicalize()
        .git_context("Failed to canonicalize worktree path")?;

    // Execute post-create commands (sequential, blocking)
    // Note: If user declines, continue anyway - worktree already created
    if !no_verify {
        let repo_root = repo.worktree_base()?;
        let ctx = CommandContext::new(
            &repo,
            config,
            &resolved_branch,
            &worktree_path,
            &repo_root,
            force,
        );
        if let Err(e) = ctx.execute_post_create_commands() {
            // Only treat CommandNotApproved as non-fatal (user declined)
            // Other errors should still fail
            if matches!(e, GitError::CommandNotApproved) {
                crate::output::info("Commands declined, continuing worktree creation")?;
            } else {
                return Err(e);
            }
        }
    }

    // Note: post-start commands are spawned AFTER success message is shown
    // (see main.rs switch handler for temporal locality)

    // Record successful switch in history for `wt switch -` support
    let _ = repo.record_switch_history(&new_current, new_previous.as_deref());

    Ok((
        SwitchResult::Created {
            path: worktree_path,
            created_branch: create,
            base_branch: base_for_creation,
        },
        resolved_branch,
    ))
}

pub fn handle_remove(
    worktree_name: &str,
    no_delete_branch: bool,
    force_delete: bool,
    background: bool,
) -> Result<RemoveResult, GitError> {
    let repo = Repository::current();

    // Show progress (unless running in background - output handler will show command)
    if !background {
        let progress_msg = format!(
            "{CYAN}Removing worktree for {CYAN_BOLD}{worktree_name}{CYAN_BOLD:#}...{CYAN:#}"
        );
        crate::output::progress(progress_msg)?;
    }

    repo.remove_worktree_by_name(worktree_name, no_delete_branch, force_delete)
}

impl<'a> CommandContext<'a> {
    /// Execute post-create commands sequentially (blocking)
    pub fn execute_post_create_commands(&self) -> Result<(), GitError> {
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_create_config) = &project_config.post_create_command else {
            return Ok(());
        };

        let pipeline = HookPipeline::new(*self);
        pipeline.run_sequential(
            post_create_config,
            CommandPhase::PostCreate,
            false,
            &[],
            "post-create",
            HookType::PostCreate,
            HookFailureStrategy::Warn,
        )
    }

    /// Spawn post-start commands in parallel as background processes (non-blocking)
    pub fn spawn_post_start_commands(&self) -> Result<(), GitError> {
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_start_config) = &project_config.post_start_command else {
            return Ok(());
        };

        let pipeline = HookPipeline::new(*self);
        pipeline.spawn_detached(
            post_start_config,
            CommandPhase::PostStart,
            false,
            &[],
            "post-start",
        )
    }

    /// Execute post-start commands sequentially (blocking) - for testing
    pub fn execute_post_start_commands_sequential(&self) -> Result<(), GitError> {
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_start_config) = &project_config.post_start_command else {
            return Ok(());
        };

        let pipeline = HookPipeline::new(*self);
        pipeline.run_sequential(
            post_start_config,
            CommandPhase::PostStart,
            false,
            &[],
            "post-start",
            HookType::PostStart,
            HookFailureStrategy::Warn,
        )
    }
}

/// Push changes to target branch
///
/// The `operations` parameter indicates which merge operations occurred (commit, squash, rebase).
/// Pass `None` for standalone push operations where these concepts don't apply.
///
/// During the push stage we temporarily `git stash` non-overlapping changes in the
/// target worktree (if present) so that concurrent edits there do not block the
/// fast-forward. The stash is restored afterward and we bail out early if any file
/// overlaps with the push range.
pub fn handle_push(
    target: Option<&str>,
    allow_merge_commits: bool,
    verb: &str,
    operations: Option<MergeOperations>,
) -> Result<(), GitError> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = repo.resolve_target_branch(target)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                "--decorate",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        // Get formatted diff stat (full terminal width - no gutter in error display)
        let term_width = crate::display::get_terminal_width();
        let files_formatted = repo
            .run_command(&[
                "diff",
                "--color=always",
                "--stat",
                &format!("--stat-width={}", term_width),
                &format!("HEAD...{}", target_branch),
            ])?
            .trim_end()
            .to_string();

        return Err(GitError::NotFastForward {
            target_branch: target_branch.to_string(),
            commits_formatted,
            files_formatted,
        });
    }

    // Check for merge commits unless allowed
    let has_merge_commits = repo.has_merge_commits(&target_branch, "HEAD")?;
    if !allow_merge_commits && has_merge_commits {
        return Err(GitError::MergeCommitsFound);
    }

    // Configure receive.denyCurrentBranch if needed
    let current_config = repo.get_config("receive.denyCurrentBranch")?;
    if current_config.as_deref() != Some("updateInstead") {
        repo.set_config("receive.denyCurrentBranch", "updateInstead")?;
    }

    // Check for conflicting changes in target worktree (auto-stash safe changes)
    let target_worktree = repo.worktree_for_branch(&target_branch)?;
    let mut target_worktree_stash =
        repo.prepare_target_worktree(target_worktree.as_ref(), &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        let cyan_dim = CYAN.dimmed();

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations - only include if we're in merge workflow context
        if let Some(ops) = operations {
            let mut skipped_ops = Vec::new();
            if !ops.committed && !ops.squashed {
                // Neither commit nor squash happened - combine them
                skipped_ops.push("commit/squash");
            }
            if !ops.rebased {
                skipped_ops.push("rebase");
            }
            if !skipped_ops.is_empty() {
                notes.push(format!("no {} needed", skipped_ops.join("/")));
            }
        }

        // Flag acknowledgments
        if allow_merge_commits && has_merge_commits {
            notes.push("merge commits allowed".to_string());
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::progress(format!(
            "{CYAN}{verb_ing} {commit_count} {commit_text} to {CYAN_BOLD}{target_branch}{CYAN_BOLD:#}{CYAN} @ {cyan_dim}{head_sha}{cyan_dim:#}{CYAN:#}{operations_note}"
        ))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            "--decorate",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::gutter(format_with_gutter(&log_output, "", None))?;

        // Show diff statistics with color (use terminal width minus gutter overhead)
        let term_width = crate::display::get_terminal_width();
        let stat_width = term_width.saturating_sub(worktrunk::styling::GUTTER_OVERHEAD);
        let diff_stat = repo.run_command(&[
            "diff",
            "--color=always",
            "--stat",
            &format!("--stat-width={}", stat_width),
            &format!("{}..HEAD", target_branch),
        ])?;

        let diff_stat = diff_stat.trim_end();
        if !diff_stat.is_empty() {
            crate::output::gutter(format_with_gutter(diff_stat, "", None))?;
        }
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    let push_target = format!("HEAD:{}", target_branch);
    if let Err(e) = repo.run_command(&["push", git_common_dir.to_str().unwrap(), &push_target]) {
        if let Some(stash) = target_worktree_stash.take() {
            stash.restore()?;
        }
        // CommandFailed contains raw git output, wrap in PushFailed for proper formatting
        return Err(GitError::PushFailed {
            error: e.to_string(),
        });
    }

    if let Some(stash) = target_worktree_stash.take() {
        stash.restore()?;
    }

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#} ({})",
            summary_parts.join(", ")
        ))?;
    } else {
        // No commits to push - for merge workflow context, acknowledge operations that didn't happen
        let note = if let Some(ops) = operations {
            let mut notes = Vec::new();
            if !ops.committed && !ops.squashed {
                notes.push("no new commits");
            }
            if !ops.rebased {
                notes.push("no rebase needed");
            }
            if notes.is_empty() {
                String::new()
            } else {
                format!(" ({})", notes.join(", "))
            }
        } else {
            // Standalone push - no merge workflow context
            String::new()
        };

        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#}{note}"
        ))?;
    }

    Ok(())
}
